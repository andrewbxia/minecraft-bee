const fft = eid("fft");
const fftr = eid("fft-r"); // fft real fit
const ffti = eid("fft-i"); // fft imag fit
const fftp = eid("fft-p"); // fft precision slider
const fftptps = eid("fft-ptps"); // points per second slider
const fftlerp = eid("fft-lerp"); // linear interpolation checkbox
const fftstart = eid("fft-start"); // let er rip
FpsMeter.init();

const bgcolor = "black";
let mode = "none";
let start = -1;
const strokes = []; // arr of strokes
const strokeidxs = [0]; // indices of stroke ENDS
const pointsize = 2;
const pointhalf = pointsize / 2;
const pointcolor = "white";
let precision = 1<<5;
const maxprec = 1 << pint(fftp.max);
const center = [0, 0];
const totalpathdt = 0.005;
let phase = 0;
let redrawpaths = true;


fftp.oninput = (e) => {
    // precision = pint(e.target.value);
    precision = 1 << pint(e.target.value);
    resetfft();
}


let ptps = 25;
fftptps.oninput = (e) => {
    ptps = sqrt(poat(e.target.value));
}
let literp = false;
const setlininterp = () => {
    literp = fftlerp.checked;
    resetfft();
}







let cutoffidx = 0; // basic undo/redo functionality


const prunestrokes = () => {
    while(strokeidxs[cutoffidx] < strokes.length){
        strokes.pop();
    }
    strokeidxs.length = cutoffidx + 1;
}
const addpoint = (x, y) => {
    strokeidxs[cutoffidx] = strokes.length;
    strokes.push([x - center[0], y - center[1]]);
}
const pushstroke = () => {
   
}
const drawpoint = (x, y, ctx, size = pointsize) =>
    ctx.fillRect(x - size/2, y - size/2, size, size);


// drawing handling
const lastclick = {x: 0, y: 0};
let movedsince = true;
/*
input methods: hold + drag to draw -> stop hold
click + move to draw -> click


*/


fft.onmousedown = (e) => {
    lastclick.x = e.clientX;
    lastclick.y = e.clientY;
    if(mode === "draw"){
        document.onmouseup(e);
        return;
    }
    mode = "draw";
    prunestrokes();
    cutoffidx++;
    document.onmousemove(e);
    movedsince = false;
}
fft.onmouseup = (e) => {
   
}


document.onmousemove = (e) => {
    if(mode === "none") return;
    // if(e.target !== fft) return; allow drawing outside
    movedsince = true;


    const rect = brect(fft);
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    addpoint(x, y);
    resetfft();
}
document.onmouseup = (e) => {
    if(!movedsince){
        movedsince = true;
        return;
    }
    if(mode === "draw"){
        // finish stroke
    }
    mode = "none";
}


// touch handling
fft.addEventListener("touchstart", (e) => {
    // e.preventDefault();
    e.clientX = e.touches[0].clientX;
    e.clientY = e.touches[0].clientY;
    fft.onmousedown(e);
});

document.addEventListener("touchmove", (e) => {
    e.preventDefault();
    e.clientX = e.touches[0].clientX;
    e.clientY = e.touches[0].clientY;
    document.onmousemove(e);
}, {passive: false});

document.addEventListener("touchend", (e) => {
    // e.preventDefault();
    document.onmouseup(e);
}, {passive: false});


const redo = () => {
    cutoffidx = min(strokeidxs.length - 1, cutoffidx + 1);
    resetfft();
}
const clr = () => {
    cutoffidx = 0;
    resetfft();
}


const undo = () => {
    cutoffidx = max(0, cutoffidx - 1);
    resetfft();
}
const map2trace = () => {
    if(totalpath.length === 0) return;
    const M = strokeidxs[cutoffidx];
    const N = nextpow2(M);
    strokes.length = N;
    for(let i = 0; i < N; i++){
        // gets point on total path (spline)
        // generated by chatgpt, no way im doing this mapth
        const t = i / N;
        const segIdx = floor(t * totalpath.length);
        const segT = (t * totalpath.length) % 1;
       
        const p0 = totalpath[arridx(segIdx - 1, totalpath.length)];
        const p1 = totalpath[segIdx];
        const p2 = totalpath[arridx(segIdx + 1, totalpath.length)];
        const p3 = totalpath[arridx(segIdx + 2, totalpath.length)];
       
        const splinepts = spline(p0, p1, p2, p3);
        const cp1 = splinepts[0];
        const cp2 = splinepts[1];
       
        const mt = 1 - segT;
        const mt2 = mt * mt;
        const mt3 = mt2 * mt;
        const t2 = segT * segT;
        const t3 = t2 * segT;
       
        const px = mt3 * p1[0] + 3 * mt2 * segT * cp1[0] + 3 * mt * t2 * cp2[0] + t3 * p2[0];
        const py = mt3 * p1[1] + 3 * mt2 * segT * cp1[1] + 3 * mt * t2 * cp2[1] + t3 * p2[1];
        strokes[i] = [px, py];
    }
    if(M < N){
        strokeidxs.push(N);
        cutoffidx++;
    }
    resetfft();
}
const fartx = (typ = 0) => {
    for(let i = 0; i < strokes.length; i++){
        const val = strokes[i][typ];
        const x = i / strokes.length * fft.width - center[0];
        const y = typ === 0 ? -val / fft.width * fft.height : val;




        strokes[i] = [x, y];


    }
    resetfft();
}
const farty = () => fartx(1);


const costerms = [];
costerms.length = maxprec + 1;
for(let k = 0; k < costerms.length; k++){
    costerms[k] = cos(pi / 2 * k / maxprec); // values from 0 to pi/2, maxprec steps
}
function getcos(theta){
    theta = theta % (2 * pi); // bring within range
    if(theta < 0) theta += 2 * pi; // get + theta
    if(theta > pi) theta = 2 * pi - theta; // bring within pi
    let idx = floor((theta / (pi / 2)) * maxprec); // get idx from 0 to pi /2

    const neg = theta > pi / 2;
    if(neg) idx = 2 * maxprec - idx; // mirror idx if negative cos

    return costerms[idx] * (neg ? -1 : 1);
}
function getsin(theta){
    return getcos(theta - pi / 2);
}

// fft stuff
class Complex{
    re = 0;
    im = 0;
    static zero = new Complex(0, 0);
    constructor(re = 0, im = 0){
        this.re = re;
        this.im = im;
    }
    plus(oth = Complex.zero, self = false){
        let ore = oth.re ?? 0;
        let oim = oth.im ?? 0;
        if(typeof oth === "object" && !(oth instanceof Complex)){
            ore = oth[0] ?? 0;
            oim = oth[1] ?? 0;
        }


        if(self){
            this.re += ore;
            this.im += oim;
            return this;
        }
        return new Complex(this.re + ore, this.im + oim);
    }
    times(oth = Complex.zero, self = false){
        let ore = oth.re ?? 0;
        let oim = oth.im ?? 0;
        if(typeof oth === "object" && !(oth instanceof Complex)){
            ore = oth[0] ?? 0;
            oim = oth[1] ?? 0;
        }
        const nre = this.re * ore - this.im * oim;
        const nim = this.re * oim + this.im * ore;
        if(self){
            this.re = nre;
            this.im = nim;
            return this;
        }
        return new Complex(nre, nim);
    }
    norm(self = false){
        const mag = max(this.mag, 1e-5);
        const nre = this.re / mag;
        const nim = this.im / mag;
        if(self){
            this.re = nre;
            this.im = nim;
            return this;
        }
        return new Complex(nre, nim);
    }
    scale(scalar = 1, self = false){
        if(self){
            this.re *= scalar;
            this.im *= scalar;
            return this;
        }
        return new Complex(this.re * scalar, this.im * scalar);
    }
    get mag(){
        return sqrt(this.re * this.re + this.im * this.im);
    }
    get phase(){
        return atan2a(this.im, this.re);
    }
    exp(){
        const r = Math.exp(this.re);
        return new Complex(r * getcos(this.im), r * getsin(this.im));
    }
    toString(){
        return `${this.re} + ${this.im}i`;
    }
}


const lerpstrokes = [];


function getstroke(idx){
    if(idx > strokeidxs[cutoffidx]){
        return lerpstrokes[idx - strokeidxs[cutoffidx]];
    }
    return strokes[idx];
}


function nextpow2(n){
    return 1 << ceil(log2(max(1, n)));
}


// helper func to have specific # of bins
function mapidx(idx, fromlen, tolen){
    return floor(idx * tolen / fromlen);
}


const expterms = [];
expterms.length = maxprec;
for(let k = 0; k < expterms.length; k++){
    expterms[k] = new Complex(0, -2 * pi * k / maxprec).exp();
}

const fftcoeffs = [];

function calcfft(arr){
    const N = arr.length;
    if(N === 1) return [arr[0]];
        // even  0, return 0 point
    if((N & (N - 1)) !== 0) terr("N not power of 2");


   
    const evens = new Array(N / 2); // splitting
    const odds  = new Array(N / 2);
    for(let i = 0; i < N / 2; i++){
        evens[i] = arr[2*i];
        odds[i]  = arr[2*i + 1];
    }


    const ffte = calcfft(evens);
    const ffto = calcfft(odds);


    const out = new Array(N);
    for(let k = 0; k < N / 2; k++){
        // const expterm = new Complex(0, -2 * pi * k / N).exp();
        const expterm = expterms[k * (maxprec / N)];
        const t = expterm.times(ffto[k]); // ffto[k] * expterm
        out[k] = t.plus(ffte[k]);         // ffte[k] + t
        out[k + N/2] = t.times([-1, 0]).plus(ffte[k]); // ffte[k] - t
    }
    return out;
}

function calcifft(arr){
    
}


function lininterp(iter){ // extends signal to 2^n
    const from = strokes[strokeidxs[cutoffidx] - 1];
    const to = strokes[0];
    const dx = to[0] - from[0];
    const dy = to[1] - from[1];


    let n = 0;
    lerpstrokes.length = iter;
    while(n < iter){
        const dt = n + 1;
        lerpstrokes[n++] = [
            from[0] + dx * (dt / iter),
            from[1] + dy * (dt / iter)
        ];
    }
}


function spline(p0, p1, p2, p3){
    const cp1 = [
        p1[0] + (p2[0] - p0[0]) / 6,
        p1[1] + (p2[1] - p0[1]) / 6
    ];
    const cp2 = [
        p2[0] - (p3[0] - p1[0]) / 6,
        p2[1] - (p3[1] - p1[1]) / 6
    ];
    return [cp1, cp2];
}
function arridx(idx, len){
    if(idx < 0) return len + idx;
    if(idx >= len) return idx - len;
    return idx;
}

function calcfit(startidx, iter){
    
    const M = strokeidxs[cutoffidx];
    const N = nextpow2(M);
    const K = fftcoeffs.length;
    const totpts = literp ? N : M;

    iter = min(iter, totpts - startidx, startidx + iter);
    for(let i = 0; i < iter; i++){
        const idx = startidx + i;
        const t = idx / totpts;

        const stroke = getstroke(idx);
        const sum = new Complex(0, 0);
        for(let k = 0; k < K; k++){
            const coeff = fftcoeffs[k];
            const freq = k < K / 2 ? k : k - K;
            const angle = t * freq * 2 * pi;
            const vec = coeff.times(new Complex(0, angle).exp()); // have to use exp
            // const vec = coeff.times(expterms[freq * (maxprec / totpts)]); 
            sum.plus(vec, true);
        }
        const diffx = abs(stroke[0] - sum.re);
        const diffy = abs(stroke[1] - sum.im);
        diffs.plus([pow(diffx, 2), pow(diffy, 2)], true);
    }
}
function calcacc(mag){
    return 2 * (mag + 1) / (pow(mag + 1, 2) + 1);
}

const totalpath = [];
const fittedpath = [];
const accs = [[], []]; // real, imag
let calcfitidx = 0;
const diffs = new Complex(0, 0);

const resetfitcalc = () => {
    const K = fftcoeffs.length;
    calcfitidx = -log2(K); // dont fit until after a cycle
    diffs.re = 0;
    diffs.im = 0;
    accs[0].length = 0;
    accs[1].length = 0;
}

const resetfft = () => {
    const then = performance.now();
    const M = strokeidxs[cutoffidx]; // # of sampels
    const z = [];
    const N = nextpow2(M);
    const K = nextpow2(precision);
    redrawpaths = true;
    if(M === 0){
        fftcoeffs.length = 0;
        totalpath.length = 0;
        return;
    }
    if(literp){
        lininterp(N - M);
    }


    for(let i = 0; i < K; i++){
        const midx = mapidx(i, K, literp ? N : M);
        z.push(getstroke(midx));
    }
   
    const C = calcfft(z);
    fftcoeffs.length = K;
    for(let k = 0; k < K; k++){
        fftcoeffs[k] = C[k].scale(1 / K);
    }
   


    // total path
    const iter = floor(1 / totalpathdt);
    totalpath.length = iter;
    for(let i = 0; i < totalpath.length; i++){
        const t = i * totalpathdt;
        let sum = Complex.zero;
        for(let k = 0; k < K; k++){
            const coeff = fftcoeffs[k];
            const freq = k < K / 2 ? k : k - K;
            const angle = t * freq * 2 * pi;
            const vec = coeff.times(new Complex(0, angle).exp());
            // const vec = coeff.times(expfitterms[freq * i]);
            sum = sum.plus(vec);
        }
        // tot path
        totalpath[i] = [sum.re, sum.im];
    }
    resetfitcalc();
    // const conj = [];
    // for(let k = 0; k < K; k++){
    //     const coeff = fftcoeffs[k];
    //     conj.push([coeff.re, -coeff.im]);
    // }
    // const ifft = calcfft(conj);
    // fittedpath.length = K;
    // for(let i = 0; i < K; i++){
    //     const c = ifft[i].scale(1);
    //     fittedpath[i] = [c.re, -c.im];
    // }
    

    // const diffs = new Complex(0, 0);
    // for(let k = 0; k < K; k++){
    //     const og = getstroke(mapidx(k, K, literp ? N : M));
    //     const fit = fittedpath[k];
    //     diffs.plus([pow((og[0] - fit[0]), 2), pow((og[1] - fit[1]), 2)], true);
    //     // log(og, fit);
    // }
    // diffs.scale(1 / K, true);
    // const acc = 2 * (diffs.mag + 1) / (pow(diffs.mag + 1, 2) + 1);
    // attachdebug(acc, diffs.toString(), diffs.mag, K)
    // eid("fit").innerText = `fit: ${(100 * acc).toFixed(2)}%`;
    attachdebug(`FFT calc time: ${((performance.now() - then)).toFixed(2)} ms`);
};
resetfft();




let ctximg = null;
let ctxrimg = null;
let ctxiimg = null;


let prevt = performance.now();
function draw(){
    const ctx = fft.getContext("2d", {willReadFrequently: true});
    const ctxr = fftr.getContext("2d", {willReadFrequently: true});
    const ctxi = ffti.getContext("2d", {willReadFrequently: true});


    const w = fft.width;
    const h = fft.height;
    const rw = fftr.width;
    const rh = fftr.height;
    const iw = ffti.width;
    const ih = ffti.height;
    // clear
    ctx.fillStyle = bgcolor;
    ctxr.fillStyle = bgcolor;
    ctxi.fillStyle = bgcolor;
    ctxi.fillRect(0, 0, iw, ih);
    ctx.fillRect(0, 0, w, h);
    ctxr.fillRect(0, 0, rw, rh);

    const M = strokeidxs[cutoffidx];
    const N = nextpow2(M);
    const totpts = literp ? N : M;

    if(redrawpaths){
        // draw points
        ctx.fillStyle = pointcolor;
        ctxr.fillStyle = pointcolor;
        ctxi.fillStyle = pointcolor;
       
        const rmult = rh / w, imult = ih / h;
        const rnorm = rw / totalpath.length, inorm = iw / totalpath.length;


        for(let idx = 0; idx < totpts; idx++){
            const p = getstroke(idx);
            drawpoint(p[0] + center[0], p[1] + center[1], ctx);
            drawpoint(idx * rw / totpts,
                -(p[0] * rmult) + rh / 2, ctxr);
            drawpoint(idx * iw / totpts,
                (p[1] * imult) + ih / 2, ctxi);
        }
        // draw center
        ctx.fillStyle = "red";
        drawpoint(center[0], center[1], ctx, 5);
        // start total path at first point


        // drawing styles
        ctx.lineWidth = 1;


        // total path
        ctx.moveTo(center[0], center[1]);
        ctx.strokeStyle = "magenta";
        ctxr.strokeStyle = "magenta";
        ctxi.strokeStyle = "magenta";
       
        ctx.beginPath();
        ctxr.beginPath();
        ctxi.beginPath();


        for(let i = 0; i < totalpath.length; i++){
            const p0 = totalpath[arridx(i - 1, totalpath.length)];
            const p1 = totalpath[i];
            const p2 = totalpath[arridx(i + 1, totalpath.length)];
            const p3 = totalpath[arridx(i + 2, totalpath.length)];


            const splinepts = spline(p0, p1, p2, p3);
            const rsplinepts = spline(
                [i * rnorm, -(p0[0] * rmult) + rh / 2],
                [i * rnorm,
                    -(p1[0] * rmult) + rh / 2],
                [(i + 1) * rnorm,
                    -(p2[0] * rmult) + rh / 2],
                [(i + 2) * rnorm,
                    -(p3[0] * rmult) + rh / 2]
                );
            const ipplinepts = spline(
                [i * inorm, (p0[1] * imult) + ih / 2],
                [i * inorm,
                    (p1[1] * imult) + ih / 2],
                [(i + 1) * inorm, (p2[1] * imult) + ih / 2],
                [(i + 2) * inorm, (p3[1] * imult) + ih / 2]
                );
           


            ctx.bezierCurveTo(
                splinepts[0][0] + center[0], splinepts[0][1] + center[1],
                splinepts[1][0] + center[0], splinepts[1][1] + center[1],
                p2[0] + center[0], p2[1] + center[1]
            );
            ctxr.bezierCurveTo(
                rsplinepts[0][0], rsplinepts[0][1],
                rsplinepts[1][0], rsplinepts[1][1],
                (i + 1) * rnorm,
                -(p2[0] * rmult) + rh / 2
            );
            ctxi.bezierCurveTo(
                ipplinepts[0][0], ipplinepts[0][1],
                ipplinepts[1][0], ipplinepts[1][1],
                (i + 1) * inorm,
                (p2[1] * imult) + ih / 2
            );


            if (debug) {
                // ctx.fillStyle = "blue";
                // drawpoint(cp1[0] - center[0], cp1[1] - center[1], ctx, 2);


                // ctx.fillStyle = "green";
                // drawpoint(cp2[0] - center[0], cp2[1] - center[1], ctx, 2);


                // ctx.fillStyle = "red";
                // drawpoint(p2[0], p2[1], ctx, 4);
            }
        }
        ctx.stroke();
        ctxr.stroke();
        ctxi.stroke();


        redrawpaths = false;
        ctximg = ctx.getImageData(0, 0, w, h);
        ctxrimg = ctxr.getImageData(0, 0, rw, rh);
        ctxiimg = ctxi.getImageData(0, 0, iw, ih);
    }
    else{
        // attachdebug(0)
        ctx.putImageData(ctximg, 0, 0);
        ctxr.putImageData(ctxrimg, 0, 0);
        ctxi.putImageData(ctxiimg, 0, 0);
    }


   
    const K = fftcoeffs.length;
    if(K === 0){
        requestAnimationFrame(draw);
        return;
    }


    const t = (performance.now() - prevt);
    prevt = performance.now();
    // points per second
    const speed = 1000 / ptps * strokeidxs[cutoffidx];
    phase += t * 2 * pi / speed;


    // start epicycle at center
    let prev = [totalpath[0][0] + center[0], totalpath[0][1] + center[1]];
    prev = [center[0], center[1]];


    // epicenters
    for(let k = 1; k <= K; k++){
        // if(k > precision) break;
        let kidx = floor(k / 2);
        if(k % 2 === 0) kidx = K - kidx;


        const coeff = fftcoeffs[kidx];
        const freq = kidx < K / 2 ? kidx : kidx - K;
        const r = coeff.mag;
        const angle = phase * freq;


        const vec = coeff.times(new Complex(0, angle).exp());
       
        // draw circle
        ctx.strokeStyle = "blue";
        ctx.beginPath();
        ctx.arc(prev[0], prev[1], r, 0, 2 * pi);
        ctx.stroke();


        // draw radius line
        ctx.strokeStyle = "white";
        ctx.beginPath();
        ctx.moveTo(prev[0], prev[1]);


       
        const nx = prev[0] + vec.re;
        const ny = prev[1] + vec.im;
        ctx.lineTo(nx, ny);
        ctx.stroke();


        prev = [nx, ny];
    }
   
    const partphase = phase % (2 * pi) * rw / (2 * pi);
    const component = [
        -(prev[0] - center[0]) * (rh / 2) / h + rh / 2,
        (prev[1] - center[1]) * rh / h + rh / 2
    ];

    ctxr.fillStyle = "rgba(125, 125, 125, 0.5)";
    ctxi.fillStyle = "rgba(125, 125, 125, 0.5)";
    ctxr.fillRect(partphase - 2, 0, 4, rh);
    ctxi.fillRect(partphase - 2, 0, 4, ih);


    ctxr.fillRect(0, component[0] - 2, rw, 4);
    ctxi.fillRect(0, component[1] - 2, iw, 4);


    ctx.fillStyle = "lime";
    ctxr.fillStyle = "lime";
    ctxi.fillStyle = "lime";
    drawpoint(prev[0], prev[1], ctx, 10);
    drawpoint(partphase, component[0], ctxr, 10);
    drawpoint(partphase, component[1], ctxi, 10);

    // fit
    const iter = log2(fftcoeffs.length);
    // const iter = fftcoeffs.length;
    
    calcfit(calcfitidx, iter);
    calcfitidx = min(calcfitidx + iter, totpts);
    const diff = diffs.scale(1 / max(1, calcfitidx * calcfitidx));
    

    const acc = 100 * calcacc(diff.mag);
    const racc = 100 * calcacc(diff.re);
    const iacc = 100 * calcacc(diff.im);

    const accidx = mapidx(calcfitidx, totpts, rw);
    accs[0][accidx] = sqrt(racc / 100) * rh;
    accs[1][accidx] = sqrt(iacc / 100) * ih;


    if(calcfitidx < totpts || true){
        ctxr.fillStyle = ctxi.fillStyle = "rgba(120, 255, 163, 0.2)";
        for(let x = 0; x < accs[0].length; x++){
            ctxr.fillRect(x, rh, ceil(iter * rw / totpts), -accs[0][x]);
            ctxi.fillRect(x, ih, ceil(iter * rw / totpts), -accs[1][x]);
        }
    }

    // attachdebug(acc, diffs.toString(), diffs.mag, K)
    eid("fit").innerText = `fit: ${acc.toFixed(2)}%`;
    
    eid("r-fit").innerText = `xfit: ${racc.toFixed(2)}%`;
    eid("i-fit").innerText = `yfit: ${iacc.toFixed(2)}%`;
    eid("fit-error").innerText = `err: ${fix2num(diff.re)}, ${fix2num(diff.im)}`;
    // eid("r-diff").innerText = `rdiff: ${diff.re.toFixed(2)}`; --- IGNORE ---
    // eid("i-diff").innerText = `idiff: ${diff.im.toFixed(2)}`; --- IGNORE ---

    eid("fit-progress").innerText = `${calcfitidx} / ${totpts}`;

    // attachdebug(mode);
    requestAnimationFrame(draw);
}



window.addEventListener("resize", () => {
    fft.width = fft.clientWidth;
    fft.height = (window.innerHeight - eid("top-menu").clientHeight);  
    fftr.width = fftr.clientWidth;
    fftr.height = fftr.clientHeight;
    ffti.width = ffti.clientWidth;
    ffti.height = ffti.clientHeight;
    center[0] = fft.width / 2;
    center[1] = fft.height / 2;
    // resetfft();
    resetfitcalc();
    redrawpaths = true;
});
window.dispatchEvent(new Event("resize"));
draw();
/*
ideas

have spline interpolation
hook up fft to audio context, sine audio data matches points drawn
like that painting video, have colors preemptivley come in or somehig


*/

